// import { writable } from'svelte/store';
// import { STRATEGIES } from '@sudoku/constants';
class Strategy {
    solve(grid) {
        console.log('This method must be overridden by subclasses');
        return grid;
    }

    // 检查在 (row, col) 位置放置 num 是否合法
    isSafe(grid, row, col, num) {
        // 检查行
        for (let i = 0; i < 9; i++) {
            if (grid[row][i] === num) return false;
        }
        // 检查列
        for (let i = 0; i < 9; i++) {
            if (grid[i][col] === num) return false;
        }
        // 检查 3x3 宫格
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (grid[startRow + i][startCol + j] === num) return false;
            }
        }
        return true;
    }

    isSolved(grid) {
        // 检查是否有未填的格子
        for (let i = 0; i < 9; i++) {
            for (let j = 0; i < 9; j++) {
                if (grid[i][j] === 0) return false;
            }
        }
        // 检查每行是否包含 1-9
        for (let i = 0; i < 9; i++) {
            const rowSet = new Set();
            for (let j = 0; j < 9; j++) {
                rowSet.add(grid[i][j]);
            }
            if (rowSet.size!== 9) return false;
        }
        // 检查每列是否包含 1-9
        for (let j = 0; j < 9; j++) {
            const colSet = new Set();
            for (let i = 0; i < 9; i++) {
                colSet.add(grid[i][j]);
            }
            if (colSet.size!== 9) return false;
        }
        // 检查每个 3x3 宫格是否包含 1-9
        for (let blockRow = 0; blockRow < 3; blockRow++) {
            for (let blockCol = 0; blockCol < 3; blockCol++) {
                const blockSet = new Set();
                for (let i = blockRow * 3; i < (blockRow + 1) * 3; i++) {
                    for (let j = blockCol * 3; j < (blockCol + 1) * 3; j++) {
                        blockSet.add(grid[i][j]);
                    }
                }
                if (blockSet.size!== 9) return false;
            }
        }
        return true;
    }

    // 找出每个空格的候选数
    findCandidates(grid) {
        const candidates = [];
        for (let i = 0; i < 9; i++) {
            candidates.push([]);
            for (let j = 0; j < 9; j++) {
                if (grid[i][j] === 0) {
                    const possible = [];
                    for (let num = 1; num <= 9; num++) {
                        if (this.isSafe(grid, i, j, num)) {
                            possible.push(num);
                        }
                    }
                    candidates[i].push(possible);
                } else {
                    candidates[i].push([]);
                }
            }
        }
        return candidates;
    }

    fillSinglesWithPropagation(grid, candidates) {
        let filled = false;
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (grid[r][c] === 0 && candidates[r][c].length === 1) {
                    const val = candidates[r][c][0];
                    grid[r][c] = val;
                    filled = true;
                    // Propagate removal to peers in `candidates`
                    this.removeCandidateFromPeers(grid, candidates, r, c, val);
                    // Clear own candidates
                    candidates[r][c] = [];
                }
            }
        }
        return filled;
    }

    removeCandidateFromPeers(grid, candidates, r, c, val) {
         // Row
         for(let j=0; j<9; j++) if(grid[r][j]===0) this.removeCand(candidates, r, j, val);
         // Col
         for(let i=0; i<9; i++) if(grid[i][c]===0) this.removeCand(candidates, i, c, val);
         // Block
         const r0 = Math.floor(r/3)*3, c0 = Math.floor(c/3)*3;
         for(let i=r0;i<r0+3;i++) for(let j=c0;j<c0+3;j++) if(grid[i][j]===0) this.removeCand(candidates, i, j, val);
    }
    
    removeCand(candidates, r, c, val) {
        const idx = candidates[r][c].indexOf(val);
        if (idx !== -1) candidates[r][c].splice(idx, 1);
    }

    getAllUnits() {
        const units = [];
        // Rows
        for (let i = 0; i < 9; i++) {
            const unit = [];
            for (let j = 0; j < 9; j++) unit.push({ r: i, c: j });
            units.push(unit);
        }
        // Cols
        for (let j = 0; j < 9; j++) {
            const unit = [];
            for (let i = 0; i < 9; i++) unit.push({ r: i, c: j });
            units.push(unit);
        }
        // Blocks
        for (let b = 0; b < 9; b++) {
            const unit = [];
            const r0 = Math.floor(b / 3) * 3;
            const c0 = (b % 3) * 3;
             for (let r = r0; r < r0 + 3; r++) {
                 for (let c = c0; c < c0 + 3; c++) {
                     unit.push({ r, c });
                 }
             }
             units.push(unit);
        }
        return units;
    }
}

class XWingStrategy extends Strategy {

    // 查找并应用 X-Wing 模式
    findXWing(candidates) {
        const steps = [];

        const processXWing = (isRow) => {
            for (let num = 1; num <= 9; num++) {
                for (let i1 = 0; i1 < 9; i1++) {
                    for (let i2 = i1 + 1; i2 < 9; i2++) {
                        const positions1 = [];
                        const positions2 = [];
                        for (let j = 0; j < 9; j++) {
                            const pos1 = isRow ? candidates[i1][j] : candidates[j][i1];
                            const pos2 = isRow ? candidates[i2][j] : candidates[j][i2];
                            if (pos1.includes(num)) positions1.push(j);
                            if (pos2.includes(num)) positions2.push(j);
                        }

                        if (
                            positions1.length === 2 &&
                            positions2.length === 2 &&
                            ((positions1[0] === positions2[0] && positions1[1] === positions2[1]) ||
                                (positions1[0] === positions2[1] && positions1[1] === positions2[0]))
                        ) {
                            // 找到 X-Wing 模式
                            const affected = [];
                            for (let i = 0; i < 9; i++) {
                                if (i !== i1 && i !== i2) {
                                    positions1.forEach((j) => {
                                        const index = isRow ? candidates[i][j].indexOf(num) : candidates[j][i].indexOf(num);
                                        if (index !== -1) {
                                            affected.push({ i, j, num });
                                            if (isRow) candidates[i][j].splice(index, 1);
                                            else candidates[j][i].splice(index, 1);
                                        }
                                    });
                                }
                            }

                            if (affected.length > 0) {
                                steps.push({
                                    type: "x-wing",
                                    num,
                                    positions: { i1, i2, positions1 },
                                    affected,
                                });
                            }
                        }
                    }
                }
            }
        };

        processXWing(true); // 行检查
        processXWing(false); // 列检查

        return steps;
    }

    solve(grid) {
        console.log('Executing X-Wing');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            
            const steps = this.findXWing(candidates);

            if (steps.length > 0) {
                steps.forEach((step) => {
                    console.log(step);
                    step.affected.forEach(({ i, j, num }) => {
                        const index = candidates[i][j].indexOf(num);
                        if (index !== -1) {
                            candidates[i][j].splice(index, 1);
                            changed = true;
                        }
                    });
                });
            }

            if (this.fillSinglesWithPropagation(grid, candidates)) changed = true;
        }
        return grid;
    }
}

class RectangleEliminationStrategy extends Strategy {
    // 检查是否存在矩形消除的模式
    find(candidates) {
        const steps = [];
        for (let num = 1; num <= 9; num++) {
            // 遍历所有元格，寻找可能的铰链单元格
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (candidates[row][col].includes(num)) {
                        // 假设当前单元格为铰链单元格
                        const hingeRow = row;
                        const hingeCol = col;
                        // 寻找与铰链单元格在同一行（或列）的另一个单元格（强链接）
                        let strongLinkRow = -1;
                        let strongLinkCol = -1;
                        for (let i = 0; i < 9; i++) {
                            if (i!== col && candidates[row][i].includes(num)) {
                                strongLinkRow = row;
                                strongLinkCol = i;
                                break;
                            }
                            if (i!== row && candidates[i][col].includes(num)) {
                                strongLinkRow = i;
                                strongLinkCol = col;
                                break;
                            }
                        }
                        if (strongLinkRow!== -1 && strongLinkCol!== -1) {
                            // 寻找与铰链单元格在相反方向（列或行）且在另一个弱链接宫格中的单元格
                            const oppositeRow = strongLinkRow === row? -1 : strongLinkRow;
                            const oppositeCol = strongLinkCol === col? -1 : strongLinkCol;
                            const boxRow = Math.floor(hingeRow / 3);
                            const boxCol = Math.floor(hingeCol / 3);
                            const oppositeBoxRow = Math.floor(oppositeRow / 3);
                            const oppositeBoxCol = Math.floor(oppositeCol / 3);
                            if (oppositeRow!== -1 && oppositeCol!== -1 && (boxRow * 3 + boxCol)!== (oppositeBoxRow * 3 + oppositeBoxCol)) {
                                // 寻找可以进行消除的单元格
                                const eliminateRow = oppositeRow === -1? row : oppositeRow;
                                const eliminateCol = oppositeCol === -1? col : oppositeCol;
                                for (let i = 0; i < 9; i++) {
                                    if (i!== hingeCol && i!== strongLinkCol && candidates[eliminateRow][i].includes(num)) {
                                        const affected = {
                                            row: eliminateRow,
                                            col: i,
                                            num: num
                                        };
                                        steps.push({
                                            type: "rectangle-elimination",
                                            num: num,
                                            hinge: { row: hingeRow, col: hingeCol },
                                            strongLink: { row: strongLinkRow, col: strongLinkCol },
                                            affected: [affected]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return steps;
    }

    solve(grid) {
        console.log('Executing Rectangle Elimination');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            
            const steps = this.find(candidates);

            if (steps.length > 0) {
                steps.forEach((step) => {
                    console.log(step);
                    step.affected.forEach(({ row, col, num }) => {
                        const index = candidates[row][col].indexOf(num);
                        if (index !== -1) {
                            candidates[row][col].splice(index, 1);
                            changed = true;
                        }
                    });
                });
            }

            if (this.fillSinglesWithPropagation(grid, candidates)) changed = true;
        }
        return grid;
    }
}

class HiddenSinglesStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Hidden Singles');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            // Removed: const candidates = this.findCandidates(grid); 
            // Candidates must persist
            
            const iterateUnits = () => {
                // Rows
                for (let i = 0; i < 9; i++) {
                    if (this.checkUnit(grid, candidates, this.getRowCells(i))) return true;
                }
                // Cols
                for (let i = 0; i < 9; i++) {
                    if (this.checkUnit(grid, candidates, this.getColCells(i))) return true;
                }
                // Blocks
                for (let i = 0; i < 9; i++) {
                    if (this.checkUnit(grid, candidates, this.getBlockCells(i))) return true;
                }
                return false;
            };

            if (iterateUnits()) {
                changed = true;
                // Since checkUnit modifies grid, we should propagate the change
                // Or checkUnit should use fillSinglesWithPropagation logic
            }
            // Standard cleanup
            if (this.fillSinglesWithPropagation(grid, candidates)) changed = true;
        }
        return grid;
    }

    checkUnit(grid, candidates, cells) {
        let localChanged = false;
        const counts = {};
        const positions = {};
        
        cells.forEach(({ r, c }) => {
            if (grid[r][c] === 0) {
                candidates[r][c].forEach(num => {
                    counts[num] = (counts[num] || 0) + 1;
                    positions[num] = { r, c };
                });
            }
        });

        for (const num in counts) {
            if (counts[num] === 1) {
                const { r, c } = positions[num];
                if (grid[r][c] === 0) { // Double check
                     grid[r][c] = parseInt(num);
                     this.removeCandidateFromPeers(grid, candidates, r, c, parseInt(num));
                     candidates[r][c] = [];
                     localChanged = true;
                }
            }
        }
        return localChanged;
    }

    getRowCells(row) {
        const cells = [];
        for (let c = 0; c < 9; c++) cells.push({ r: row, c: c });
        return cells;
    }
    getColCells(col) {
        const cells = [];
        for (let r = 0; r < 9; r++) cells.push({ r: r, c: col });
        return cells;
    }
    getBlockCells(block) {
        const cells = [];
        const startRow = Math.floor(block / 3) * 3;
        const startCol = (block % 3) * 3;
        for (let r = startRow; r < startRow + 3; r++) {
            for (let c = startCol; c < startCol + 3; c++) {
                cells.push({ r, c });
            }
        }
        return cells;
    }
}

class NakedPairsStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Naked Pairs');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            // Removed: let candidates = this.findCandidates(grid);
            if (this.applyNakedPairs(grid, candidates)) { changed = true; }
            // Note: If applyNakedPairs finds something, it modifies 'candidates'. 
            // We set changed=true so we loop again to see if that leads to more findings.
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
        }
        return grid;
    }

    applyNakedPairs(grid, candidates) {
        let found = false;
        const units = this.getAllUnits();
        for (const unit of units) {
            // Find cells with exactly 2 candidates
            const pairs = [];
            for (const { r, c } of unit) {
                if (grid[r][c] === 0 && candidates[r][c].length === 2) {
                    pairs.push({ r, c, cands: candidates[r][c] });
                }
            }
            
            // Check for matching pairs
            for (let i = 0; i < pairs.length; i++) {
                for (let j = i + 1; j < pairs.length; j++) {
                    const p1 = pairs[i];
                    const p2 = pairs[j];
                    if (p1.cands[0] === p2.cands[0] && p1.cands[1] === p2.cands[1]) {
                        // Found Naked Pair. Eliminate these numbers from other cells in unit
                        const val1 = p1.cands[0];
                        const val2 = p1.cands[1];
                        
                        for (const { r, c } of unit) {
                            if ((r !== p1.r || c !== p1.c) && (r !== p2.r || c !== p2.c) && grid[r][c] === 0) {
                                const idx1 = candidates[r][c].indexOf(val1);
                                if (idx1 !== -1) { candidates[r][c].splice(idx1, 1); found = true; }
                                const idx2 = candidates[r][c].indexOf(val2);
                                if (idx2 !== -1) { candidates[r][c].splice(idx2, 1); found = true; }
                            }
                        }
                    }
                }
            }
            if (found) break; // Restart loop if found to avoid conflicts? Or continue? Break is safer.
        }
        return found;
    }
}

class HiddenPairsStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Hidden Pairs');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            if (this.applyHiddenPairs(grid, candidates)) { changed = true; }
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
        }
        return grid;
    }

    applyHiddenPairs(grid, candidates) {
        let found = false;
        const units = this.getAllUnits();
        for (const unit of units) {
            const counts = {}; // num -> count
            const locs = {};   // num -> [{r,c}, ...]
            
            // Map candidates
            for (const { r, c } of unit) {
               if (grid[r][c] === 0) {
                   candidates[r][c].forEach(num => {
                       counts[num] = (counts[num] || 0) + 1;
                       if (!locs[num]) locs[num] = [];
                       locs[num].push({ r, c });
                   });
               }
            }

            // Find numbers with count 2
            const candidatesCount2 = Object.keys(counts).filter(k => counts[k] === 2).map(Number);
            
            for (let i = 0; i < candidatesCount2.length; i++) {
                for (let j = i + 1; j < candidatesCount2.length; j++) {
                    const n1 = candidatesCount2[i];
                    const n2 = candidatesCount2[j];
                    
                    const locs1 = locs[n1];
                    const locs2 = locs[n2];
                    
                    if (locs1[0].r === locs2[0].r && locs1[0].c === locs2[0].c &&
                        locs1[1].r === locs2[1].r && locs1[1].c === locs2[1].c) {
                            
                        // Found Hidden Pair (n1, n2) at (r1,c1) and (r2,c2)
                        // Remove all OTHER candidates from these two cells
                        const cell1 = locs1[0];
                        const cell2 = locs1[1];
                        
                        const pairVals = [n1, n2].sort();
                        
                        // Proceed only if there are other candidates to remove
                        if (candidates[cell1.r][cell1.c].length > 2 || candidates[cell2.r][cell2.c].length > 2) {
                            // Check if logic holds (we are not overwriting previous step in same iter)
                             if (grid[cell1.r][cell1.c] === 0 && grid[cell2.r][cell2.c] === 0) {
                                candidates[cell1.r][cell1.c] = pairVals;
                                candidates[cell2.r][cell2.c] = pairVals;
                                found = true;
                             }
                        }
                    }
                }
            }
            if (found) break;
        }
        return found;
    }
}

class PointingPairsStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Pointing Pairs');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            if (this.applyPointingPairs(grid, candidates)) { changed = true; }
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
        }
        return grid;
    }

    applyPointingPairs(grid, candidates) {
        let found = false;
        
        for (let b = 0; b < 9; b++) {
            // For each block
            const blockCells = this.getBlockCells(b);
            const r0 = Math.floor(b / 3) * 3;
            const c0 = (b % 3) * 3;
            
            // Check each number 1-9
            for (let num = 1; num <= 9; num++) {
                const locations = [];
                for (const { r, c } of blockCells) {
                    if (grid[r][c] === 0 && candidates[r][c].includes(num)) {
                        locations.push({ r, c });
                    }
                }
                
                if (locations.length > 1) {
                    // Check if all in same row
                    const firstRow = locations[0].r;
                    const allSameRow = locations.every(l => l.r === firstRow);
                    
                    if (allSameRow) {
                        // Remove num from other cells in this row
                        for (let c = 0; c < 9; c++) {
                             // Check if (firstRow, c) is NOT in current block
                             if (c < c0 || c >= c0 + 3) {
                                 if (grid[firstRow][c] === 0) {
                                     const idx = candidates[firstRow][c].indexOf(num);
                                     if (idx !== -1) {
                                         candidates[firstRow][c].splice(idx, 1);
                                         found = true;
                                     }
                                 }
                             }
                        }
                    }

                    // Check if all in same col
                    const firstCol = locations[0].c;
                    const allSameCol = locations.every(l => l.c === firstCol);
                    
                     if (allSameCol) {
                        // Remove num from other cells in this col
                        for (let r = 0; r < 9; r++) {
                             // Check if (r, firstCol) is NOT in current block
                             if (r < r0 || r >= r0 + 3) {
                                 if (grid[r][firstCol] === 0) {
                                     const idx = candidates[r][firstCol].indexOf(num);
                                     if (idx !== -1) {
                                         candidates[r][firstCol].splice(idx, 1);
                                         found = true;
                                     }
                                 }
                             }
                        }
                    }
                }
            }
        }
        return found;
    }

     getBlockCells(block) {
        const cells = [];
        const startRow = Math.floor(block / 3) * 3;
        const startCol = (block % 3) * 3;
        for (let r = startRow; r < startRow + 3; r++) {
            for (let c = startCol; c < startCol + 3; c++) {
                cells.push({ r, c });
            }
        }
        return cells;
    }
}

class BoxLineReductionStrategy extends Strategy {
    solve(grid) {
         console.log('Executing Box/Line Reduction');
         let candidates = this.findCandidates(grid);
         let changed = true;
         while (changed) {
            changed = false;
            if (this.applyBoxLineReduction(grid, candidates)) { changed = true; }
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
         }
         return grid;
    }

    applyBoxLineReduction(grid, candidates) {
        let found = false;
        
        // Rows
        for (let r = 0; r < 9; r++) {
            for (let num = 1; num <= 9; num++) {
                const locations = [];
                for (let c = 0; c < 9; c++) {
                     if (grid[r][c] === 0 && candidates[r][c].includes(num)) {
                         locations.push({r, c});
                     }
                }
                
                if (locations.length > 1) {
                    // Check if all locations are in the same block
                    const firstBlock = Math.floor(locations[0].r / 3) * 3 + Math.floor(locations[0].c / 3);
                    const allSameBlock = locations.every(l => (Math.floor(l.r / 3) * 3 + Math.floor(l.c / 3)) === firstBlock);
                    
                    if (allSameBlock) {
                        // Remove num from other cells in that block
                        const r0 = Math.floor(firstBlock / 3) * 3;
                        const c0 = (firstBlock % 3) * 3;
                        
                        for (let br = r0; br < r0 + 3; br++) {
                            for (let bc = c0; bc < c0 + 3; bc++) {
                                // Exclude the current row r
                                if (br !== r) {
                                    if (grid[br][bc] === 0) {
                                        const idx = candidates[br][bc].indexOf(num);
                                        if (idx !== -1) {
                                            candidates[br][bc].splice(idx, 1);
                                            found = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Cols - Similar logic
         for (let c = 0; c < 9; c++) {
            for (let num = 1; num <= 9; num++) {
                const locations = [];
                for (let r = 0; r < 9; r++) {
                     if (grid[r][c] === 0 && candidates[r][c].includes(num)) {
                         locations.push({r, c});
                     }
                }
                
                if (locations.length > 1) {
                    const firstBlock = Math.floor(locations[0].r / 3) * 3 + Math.floor(locations[0].c / 3);
                    const allSameBlock = locations.every(l => (Math.floor(l.r / 3) * 3 + Math.floor(l.c / 3)) === firstBlock);
                    
                    if (allSameBlock) {
                        const r0 = Math.floor(firstBlock / 3) * 3;
                        const c0 = (firstBlock % 3) * 3;
                        
                        for (let br = r0; br < r0 + 3; br++) {
                            for (let bc = c0; bc < c0 + 3; bc++) {
                                if (bc !== c) {
                                    if (grid[br][bc] === 0) {
                                        const idx = candidates[br][bc].indexOf(num);
                                        if (idx !== -1) {
                                            candidates[br][bc].splice(idx, 1);
                                            found = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return found;
    }
}

class TriplesStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Triples (Naked + Hidden)');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            if (this.applyNakedTriples(grid, candidates)) { changed = true; }
            if (this.applyHiddenTriples(grid, candidates)) { changed = true; }
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
        }
        return grid;
    }

    // fillSingles removed

    applyNakedTriples(grid, candidates) {
        let found = false;
        const units = this.getAllUnits();
        
        for (const unit of units) {
            const cells = unit.filter(({r,c}) => grid[r][c] === 0 && candidates[r][c].length >= 2 && candidates[r][c].length <= 3);
            
            if (cells.length >= 3) {
                 for (let i = 0; i < cells.length; i++) {
                    for (let j = i + 1; j < cells.length; j++) {
                        for (let k = j + 1; k < cells.length; k++) {
                            const c1 = candidates[cells[i].r][cells[i].c];
                            const c2 = candidates[cells[j].r][cells[j].c];
                            const c3 = candidates[cells[k].r][cells[k].c];
                            
                            // Union of candidates
                            const union = new Set([...c1, ...c2, ...c3]);
                            
                            if (union.size === 3) {
                                // Naked Triple found!
                                const tripleNums = Array.from(union);
                                
                                // Remove these nums from other cells
                                for (const {r, c} of unit) {
                                    if ((r===cells[i].r && c===cells[i].c) || 
                                        (r===cells[j].r && c===cells[j].c) || 
                                        (r===cells[k].r && c===cells[k].c)) continue;
                                    
                                    if (grid[r][c] === 0) {
                                        let originalLen = candidates[r][c].length;
                                        tripleNums.forEach(num => {
                                            const idx = candidates[r][c].indexOf(num);
                                            if (idx !== -1) candidates[r][c].splice(idx, 1);
                                        });
                                        if (candidates[r][c].length !== originalLen) found = true;
                                    }
                                }
                            }
                        }
                    }
                 }
            }
            if (found) break;
        }
        return found;
    }
    
    applyHiddenTriples(grid, candidates) {
        let found = false;
         const units = this.getAllUnits();
         
         for (const unit of units) {
              const counts = {};
              const locs = {};
              for (const {r, c} of unit) {
                  if (grid[r][c] === 0) {
                      candidates[r][c].forEach(n => {
                          counts[n] = (counts[n] || 0) + 1;
                          if (!locs[n]) locs[n] = [];
                          locs[n].push({r, c});
                      });
                  }
              }
              
              // Only consider numbers appearing 2 or 3 times
              const cands = Object.keys(counts).filter(n => counts[n] >= 2 && counts[n] <= 3).map(Number);
              
              if (cands.length >= 3) {
                  for (let i = 0; i < cands.length; i++) {
                      for (let j = i+1; j < cands.length; j++) {
                          for (let k = j+1; k < cands.length; k++) {
                               const n1 = cands[i], n2 = cands[j], n3 = cands[k];
                               // Collect all unique locations for these 3 numbers
                               const pos = new Set();
                               [...locs[n1], ...locs[n2], ...locs[n3]].forEach(p => pos.add(`${p.r},${p.c}`));
                               
                               if (pos.size === 3) {
                                   // Hidden Triple
                                   const positions = Array.from(pos).map(s => {
                                       const [r, c] = s.split(',');
                                       return {r: parseInt(r), c: parseInt(c)};
                                   });
                                   
                                   const tripleNums = [n1, n2, n3];
                                   
                                   // Remove other numbers from these 3 positions
                                   positions.forEach(({r, c}) => {
                                       const currentCands = candidates[r][c];
                                       if (currentCands.some(n => !tripleNums.includes(n))) {
                                            candidates[r][c] = currentCands.filter(n => tripleNums.includes(n));
                                            found = true;
                                       }
                                   });
                               }
                          }
                      }
                  }
              }
              if (found) break;
         }
         return found;
    }
}

class QuadsStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Quads (Naked + Hidden)');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            if (this.applyNakedQuads(grid, candidates)) { changed = true; }
            if (this.applyHiddenQuads(grid, candidates)) { changed = true; }
            if (this.fillSinglesWithPropagation(grid, candidates)) { changed = true; }
        }
        return grid;
    }

    // fillSingles removed

    applyNakedQuads(grid, candidates) {
        let found = false;
        const units = this.getAllUnits();
        
        for (const unit of units) {
            const cells = unit.filter(({r,c}) => grid[r][c] === 0 && candidates[r][c].length >= 2 && candidates[r][c].length <= 4);
            
            if (cells.length >= 4) {
                 for (let i = 0; i < cells.length; i++) {
                    for (let j = i + 1; j < cells.length; j++) {
                        for (let k = j + 1; k < cells.length; k++) {
                            for (let l = k + 1; l < cells.length; l++) {
                                const c1 = candidates[cells[i].r][cells[i].c];
                                const c2 = candidates[cells[j].r][cells[j].c];
                                const c3 = candidates[cells[k].r][cells[k].c];
                                const c4 = candidates[cells[l].r][cells[l].c];
                                
                                const union = new Set([...c1, ...c2, ...c3, ...c4]);
                                
                                if (union.size === 4) {
                                    const quadNums = Array.from(union);
                                    for (const {r, c} of unit) {
                                        if ((r===cells[i].r && c===cells[i].c) || 
                                            (r===cells[j].r && c===cells[j].c) || 
                                            (r===cells[k].r && c===cells[k].c) ||
                                            (r===cells[l].r && c===cells[l].c)) continue;
                                        
                                        if (grid[r][c] === 0) {
                                            let originalLen = candidates[r][c].length;
                                            quadNums.forEach(num => {
                                                const idx = candidates[r][c].indexOf(num);
                                                if (idx !== -1) candidates[r][c].splice(idx, 1);
                                            });
                                            if (candidates[r][c].length !== originalLen) found = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                 }
            }
            if (found) break;
        }
        return found;
    }
    
    applyHiddenQuads(grid, candidates) {
        let found = false;
         const units = this.getAllUnits();
         
         for (const unit of units) {
              const counts = {};
              const locs = {};
              for (const {r, c} of unit) {
                  if (grid[r][c] === 0) {
                      candidates[r][c].forEach(n => {
                          counts[n] = (counts[n] || 0) + 1;
                          if (!locs[n]) locs[n] = [];
                          locs[n].push({r, c});
                      });
                  }
              }
              
              const cands = Object.keys(counts).filter(n => counts[n] >= 2 && counts[n] <= 4).map(Number);
              
              if (cands.length >= 4) {
                  for (let i = 0; i < cands.length; i++) {
                      for (let j = i+1; j < cands.length; j++) {
                          for (let k = j+1; k < cands.length; k++) {
                              for (let l = k+1; l < cands.length; l++) {
                                   const n1 = cands[i], n2 = cands[j], n3 = cands[k], n4 = cands[l];
                                   const pos = new Set();
                                   [...locs[n1], ...locs[n2], ...locs[n3], ...locs[n4]].forEach(p => pos.add(`${p.r},${p.c}`));
                                   
                                   if (pos.size === 4) {
                                       const positions = Array.from(pos).map(s => {
                                           const [r, c] = s.split(',');
                                           return {r: parseInt(r), c: parseInt(c)};
                                       });
                                       const quadNums = [n1, n2, n3, n4];
                                       
                                       positions.forEach(({r, c}) => {
                                           const currentCands = candidates[r][c];
                                           if (currentCands.some(n => !quadNums.includes(n))) {
                                                candidates[r][c] = currentCands.filter(n => quadNums.includes(n));
                                                found = true;
                                           }
                                       });
                                   }
                              }
                          }
                      }
                  }
              }
              if (found) break;
         }
         return found;
    }
}

class SwordfishStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Swordfish');
        let candidates = this.findCandidates(grid);
        let changed = true;
        while (changed) {
            changed = false;
            
            // Rows -> Cols
            if (this.applySwordfish(candidates, true)) changed = true;
            // Cols -> Rows
            if (this.applySwordfish(candidates, false)) changed = true;
            
            if (this.fillSinglesWithPropagation(grid, candidates)) changed = true;
        }
        return grid;
    }

    applySwordfish(candidates, isRow) {
        let found = false;
        const SIZE = 9;
        
        for (let num = 1; num <= 9; num++) {
            const potentialLines = []; 
            for (let i = 0; i < 9; i++) {
                const positions = [];
                for (let j = 0; j < 9; j++) {
                    let r = isRow ? i : j;
                    let c = isRow ? j : i;
                    if (candidates[r][c].includes(num)) {
                        positions.push(j); // Store the secondary coordinate
                    }
                }
                if (positions.length >= 2 && positions.length <= 3) {
                    potentialLines.push({ idx: i, pos: positions });
                }
            }

            if (potentialLines.length >= 3) {
                for (let i = 0; i < potentialLines.length; i++) {
                    for (let j = i + 1; j < potentialLines.length; j++) {
                        for (let k = j + 1; k < potentialLines.length; k++) {
                            const l1 = potentialLines[i], l2 = potentialLines[j], l3 = potentialLines[k];
                            const distinctPos = new Set([...l1.pos, ...l2.pos, ...l3.pos]);
                            
                            if (distinctPos.size === 3) {
                                // Swordfish found
                                const cols = Array.from(distinctPos);
                                const rowsToExclude = [l1.idx, l2.idx, l3.idx];
                                
                                // Eliminate num from these cols/rows in OTHER lines
                                for (let p of cols) {
                                    for (let x = 0; x < 9; x++) {
                                        if (!rowsToExclude.includes(x)) {
                                            let r = isRow ? x : p;
                                            let c = isRow ? p : x;
                                            const index = candidates[r][c].indexOf(num);
                                            if (index !== -1) {
                                                candidates[r][c].splice(index, 1);
                                                found = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return found;
    }
}

class BUGPlusOneStrategy extends Strategy {
    solve(grid) {
        console.log('Executing BUG+1');
        let candidates = this.findCandidates(grid);
        const undefinedCells = [];
        for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) undefinedCells.push({r,c, cands: candidates[r][c]});
        
        const triValueCells = undefinedCells.filter(u => u.cands.length === 3);
        const biValueCells = undefinedCells.filter(u => u.cands.length === 2);
        
        if (triValueCells.length === 1 && (triValueCells.length + biValueCells.length === undefinedCells.length)) {
            // Potential BUG+1
            const cell = triValueCells[0];
            const { r, c, cands } = cell;
            
            // For each candidate in the tri-value cell, check how many times it appears in row, col, block.
            // In a BUG state, every candidate appears twice in row/col/block.
            // In BUG+1, one candidate appears 3 times. This is the solution.
            
            for (let num of cands) {
                let rowCount = 0, colCount = 0, blockCount = 0;
                // Count in Row
                for(let j=0; j<9; j++) if(grid[r][j]===0 && candidates[r][j].includes(num)) rowCount++;
                // Count in Col
                for(let i=0; i<9; i++) if(grid[i][c]===0 && candidates[i][c].includes(num)) colCount++;
                // Count in Block
                const r0 = Math.floor(r/3)*3, c0 = Math.floor(c/3)*3;
                for(let i=r0;i<r0+3;i++) for(let j=c0;j<c0+3;j++) if(grid[i][j]===0 && candidates[i][j].includes(num)) blockCount++;
                
                if (rowCount === 3 || colCount === 3 || blockCount === 3) {
                     grid[r][c] = num;
                     console.log(`BUG+1 applied at ${r+1},${c+1} set to ${num}`);
                     return grid; 
                }
            }
        }
        return grid;
    }
}

class YWingStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Y-Wing');
         let candidates = this.findCandidates(grid);
         let changed = true;
         while (changed) {
             changed = false;
             if (this.applyYWing(candidates)) changed = true;
             
             if (this.fillSinglesWithPropagation(grid, candidates)) changed = true;
         }
         return grid;
    }

    applyYWing(candidates) {
        let found = false;
        const biCells = [];
         for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(candidates[r][c].length===2) biCells.push({r,c, val: candidates[r][c]});
         
         for (let i = 0; i < biCells.length; i++) {
             const pivot = biCells[i];
             // Find pincers
             for (let j = 0; j < biCells.length; j++) {
                 if (i===j) continue;
                 const p1 = biCells[j];
                 if (!this.sees(pivot, p1)) continue;
                 
                 for (let k = j + 1; k < biCells.length; k++) {
                      if (i===k) continue;
                      const p2 = biCells[k];
                      if (!this.sees(pivot, p2)) continue;
                      
                      // Check values
                      // Pivot: AB. P1: AC. P2: BC.
                      const allCands = [...pivot.val, ...p1.val, ...p2.val];
                      const distinct = new Set(allCands);
                      if (distinct.size !== 3) continue;
                      
                      const pivotSet = new Set(pivot.val);
                      const p1Set = new Set(p1.val);
                      const p2Set = new Set(p2.val);
                      
                      // Pivot must share one with P1 and one with P2
                      const share1 = pivot.val.filter(x => p1.val.includes(x));
                      const share2 = pivot.val.filter(x => p2.val.includes(x));
                      
                      if(share1.length===1 && share2.length===1 && share1[0]!==share2[0]) {
                          // Check if P1 and P2 share the third number Z
                          const zCandidate = p1.val.find(x => x !== share1[0]);
                          if (p2.val.includes(zCandidate)) {
                              // Found Y-Wing! Pivot: XY, P1: XZ, P2: YZ. zCandidate is Z.
                              // Eliminate Z from cells seeing both P1 and P2
                              if (this.eliminateCommon(candidates, p1, p2, zCandidate)) found = true;
                          }
                      }
                 }
             }
         }
         return found;
    }

    sees(c1, c2) {
        if (c1.r === c2.r) return true;
        if (c1.c === c2.c) return true;
        if (Math.floor(c1.r/3) === Math.floor(c2.r/3) && Math.floor(c1.c/3) === Math.floor(c2.c/3)) return true;
        return false;
    }

    eliminateCommon(candidates, c1, c2, num) {
        let changed = false;
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if ((r===c1.r && c===c1.c) || (r===c2.r && c===c2.c)) continue;
                if (candidates[r][c].includes(num)) {
                    if (this.sees({r,c}, c1) && this.sees({r,c}, c2)) {
                        candidates[r][c].splice(candidates[r][c].indexOf(num), 1);
                        changed = true;
                    }
                }
            }
        }
        return changed;
    }
}

class UniqueRectanglesStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Unique Rectangles Type 1');
        let candidates = this.findCandidates(grid);
        let changed = false;
        
        // Find 4 cells forming a rectangle in 2 blocks
        // Iterate all pairs of rows
        for (let r1 = 0; r1 < 9; r1++) {
            for (let r2 = r1 + 1; r2 < 9; r2++) {
                // Iterate all pairs of cols
                for (let c1 = 0; c1 < 9; c1++) {
                    for (let c2 = c1 + 1; c2 < 9; c2++) {
                        // Check if they form a rectangle in 2 blocks
                        // (r1,c1) and (r2,c1) must be in same block? No, (r1,c1) and (r2,c1) are in same col.
                        // (r1,c1) and (r1,c2) must be in same block OR (r1,c1) and (r2,c1) in same block.
                        // For Unique Rectangle, the four cells typically span exactly two blocks.
                        // So (r1,c1) and (r2,c1) in same block, (r1,c2) and (r2,c2) in same block.
                        
                        const b1 = Math.floor(r1/3)*3 + Math.floor(c1/3);
                        const b2 = Math.floor(r2/3)*3 + Math.floor(c1/3);
                        const b3 = Math.floor(r1/3)*3 + Math.floor(c2/3);
                        const b4 = Math.floor(r2/3)*3 + Math.floor(c2/3);
                        
                        if (b1 === b2 && b3 === b4 && b1 !== b3) {
                             // Valid UR structure
                             const cells = [
                                 {r:r1, c:c1, cands: candidates[r1][c1]},
                                 {r:r2, c:c1, cands: candidates[r2][c1]},
                                 {r:r1, c:c2, cands: candidates[r1][c2]},
                                 {r:r2, c:c2, cands: candidates[r2][c2]}
                             ];
                             
                             // Check candidate structure for Type 1
                             // 3 cells have exactly 2 candidates {X,Y}. 4th cell has {X,Y} + others.
                             // 4th cell cannot be X or Y (otherwise deadly pattern).
                             
                             // Find the "floor" cells (size 2)
                             const floor = cells.filter(cell => cell.cands.length === 2);
                             if (floor.length === 3) {
                                  // Check if they share the same pair
                                  const c1 = floor[0].cands, c2 = floor[1].cands, c3 = floor[2].cands;
                                  if (c1[0]===c2[0] && c1[1]===c2[1] && c1[0]===c3[0] && c1[1]===c3[1]) {
                                      // Candidates match!
                                      const pair = c1;
                                      const target = cells.find(cell => cell.cands.length > 2);
                                      if (target && target.cands.includes(pair[0]) && target.cands.includes(pair[1])) {
                                          // Found Type 1
                                          const idx1 = candidates[target.r][target.c].indexOf(pair[0]);
                                          if (idx1 !== -1) candidates[target.r][target.c].splice(idx1, 1);
                                          const idx2 = candidates[target.r][target.c].indexOf(pair[1]);
                                          if (idx2 !== -1) candidates[target.r][target.c].splice(idx2, 1);
                                          changed = true;
                                      }
                                  }
                             }
                        }
                    }
                }
            }
        }
        
        if (changed) {
            for(let i=0;i<9;i++) for(let j=0;j<9;j++) if(grid[i][j]===0 && candidates[i][j].length===1) grid[i][j] = candidates[i][j][0];
        }
        return grid;
    }
}

class RemotePairsStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Chute Remote Pairs');
        let candidates = this.findCandidates(grid);
        let changed = false;
        
        // Find pairs
        const pairs = [];
        for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(candidates[r][c].length === 2) pairs.push({r,c, val: candidates[r][c].sort().join('')});
        
        const grouped = {};
        pairs.forEach(p => {
            if (!grouped[p.val]) grouped[p.val] = [];
            grouped[p.val].push(p);
        });
        
        for (const key in grouped) {
            const group = grouped[key];
            if (group.length < 4) continue; // Need at least 4 for a chain
            
            // Build graph
            const adj = Array(group.length).fill(0).map(() => []);
            for(let i=0; i<group.length; i++) {
                for(let j=i+1; j<group.length; j++) {
                    if (this.sees(group[i], group[j])) {
                        adj[i].push(j);
                        adj[j].push(i);
                    }
                }
            }
            
            // DFS for chain
            // Simplified: Color graph with 2 colors. All nodes in connected component.
            const colors = Array(group.length).fill(0); // 0: unvisited, 1: color A, 2: color B
             for(let i=0; i<group.length; i++) {
                 if (colors[i] === 0) {
                     // BFS/DFS component
                     const stack = [{idx: i, c: 1}];
                     colors[i] = 1;
                     const componentNodes = [i];
                     
                     while(stack.length) {
                         const {idx, c} = stack.pop();
                         const nextC = c === 1 ? 2 : 1;
                         for(let neighbor of adj[idx]) {
                             if(colors[neighbor] === 0) {
                                 colors[neighbor] = nextC;
                                 componentNodes.push(neighbor);
                                 stack.push({idx: neighbor, c: nextC});
                             }
                         }
                     }
                     
                     // Check eliminations
                     const color1Nodes = componentNodes.filter(n => colors[n] === 1).map(n => group[n]);
                     const color2Nodes = componentNodes.filter(n => colors[n] === 2).map(n => group[n]);
                     
                     // Rule: Any cell seeing a Color 1 node AND a Color 2 node cannot contain the pair numbers
                     const nums = group[i].val.split('').map(Number);
                     
                     for (let r=0; r<9; r++) {
                         for (let c=0; c<9; c++) {
                             if (grid[r][c]===0 && candidates[r][c].length > 0) {
                                 // optimization: strictly check if cell has candidates to remove
                                 if (!candidates[r][c].includes(nums[0]) && !candidates[r][c].includes(nums[1])) continue;
                                 if (group.find(g => g.r===r && g.c===c)) continue; // Don't process chain cells themselves
                                 
                                 let sees1 = false, sees2 = false;
                                 for(let n1 of color1Nodes) if(this.sees({r,c}, n1)) { sees1 = true; break; }
                                 if (!sees1) continue;
                                 for(let n2 of color2Nodes) if(this.sees({r,c}, n2)) { sees2 = true; break; }
                                 
                                 if (sees1 && sees2) {
                                     // Remove values
                                     [nums[0], nums[1]].forEach(n => {
                                         const idx = candidates[r][c].indexOf(n);
                                         if (idx !== -1) {
                                             candidates[r][c].splice(idx, 1);
                                             changed = true;
                                         }
                                     });
                                 }
                             }
                         }
                     }
                 }
             }
        }

        if (changed) {
            for(let i=0;i<9;i++) for(let j=0;j<9;j++) if(grid[i][j]===0 && candidates[i][j].length===1) grid[i][j] = candidates[i][j][0];
        }
        return grid;
    }
    sees(c1, c2) {
        if (c1.r === c2.r) return true;
        if (c1.c === c2.c) return true;
        if (Math.floor(c1.r/3) === Math.floor(c2.r/3) && Math.floor(c1.c/3) === Math.floor(c2.c/3)) return true;
        return false;
    }
}

class SimpleColouringStrategy extends Strategy {
    solve(grid) {
        console.log('Executing Simple Colouring');
        let candidates = this.findCandidates(grid);
        let changed = false;
        
        for (let num = 1; num <= 9; num++) {
             const nodes = [];
             for(let r=0;r<9;r++) for(let c=0;c<9;c++) 
                if(candidates[r][c].includes(num)) nodes.push({r,c, idx: nodes.length});
             
             if (nodes.length === 0) continue;
             
             // Build graph of Conjugate Pairs (Strong Links)
             // Two cells share a unit AND are the ONLY two cells in that unit with candidate num
             const adj = Array(nodes.length).fill(0).map(() => []);
             
             // Check Rows
             for(let r=0; r<9; r++) {
                 const rowNodes = nodes.filter(n => n.r === r);
                 if (rowNodes.length === 2) {
                     adj[rowNodes[0].idx].push(rowNodes[1].idx);
                     adj[rowNodes[1].idx].push(rowNodes[0].idx);
                 }
             }
             // Cols
             for(let c=0; c<9; c++) {
                 const colNodes = nodes.filter(n => n.c === c);
                 if (colNodes.length === 2) {
                     adj[colNodes[0].idx].push(colNodes[1].idx);
                     adj[colNodes[1].idx].push(colNodes[0].idx);
                 }
             }
             // Blocks
             for(let b=0; b<9; b++) {
                  const bNodes = nodes.filter(n => Math.floor(n.r/3)*3 + Math.floor(n.c/3) === b);
                  if (bNodes.length === 2) {
                      adj[bNodes[0].idx].push(bNodes[1].idx);
                      adj[bNodes[1].idx].push(bNodes[0].idx);
                  }
             }
             
             const colors = Array(nodes.length).fill(0);
             for(let i=0; i<nodes.length; i++) {
                 if(colors[i] === 0) {
                     const stack = [{idx: i, c: 1}];
                     colors[i] = 1;
                     const component = [i];
                     let possible = true;
                     const colorOneNodes = [];
                     const colorTwoNodes = [];
                     
                     while(stack.length) {
                         const {idx, c} = stack.pop();
                         if(c===1) colorOneNodes.push(nodes[idx]); else colorTwoNodes.push(nodes[idx]);
                         
                         const nextC = c === 1 ? 2 : 1;
                         for(let neighbor of adj[idx]) {
                             if(colors[neighbor] === 0) {
                                 colors[neighbor] = nextC;
                                 component.push(neighbor);
                                 stack.push({idx: neighbor, c: nextC});
                             } else if (colors[neighbor] === c) {
                                  // Rule 1: Two colors in same unit -> Candidate N is impossible for this color
                                  // Wait, "Two nodes of same color share a unit" -> That color is false.
                                  // Check if they share a unit. Since they are connected by strong link logic, we built adj on strong links.
                                  // But we need to check weak links (visibility).
                                  // Here, if we encounter exact same color in traversal of strong links, it implies loop. 
                                  // But standard Simple Coloring says: if two candidates of same color see each other, remove all candidates of that color.
                             }
                         }
                     }
                     
                     // Apply Rule 2: Remove candidate from any cell seeing both colors
                     // Iter all other cells with candidate
                     const otherNodes = nodes.filter(n => !component.includes(n.idx));
                     
                     // Or even cells without candidate/processed node (if we just want to remove candidate, we only care about cells having it)
                     // Actually, we check ALL nodes having num (including those in graph but different components, or weak linked).
                     // Ideally check all uncolored cells with candidate num.
                     
                     // Optimization: Check for Rule 1 (Twice in a unit)
                     let removeColor1 = false;
                     let removeColor2 = false;
                     
                     // Helper: Check if any two nodes in list see each other
                     const hasConflict = (list) => {
                         for(let x=0; x<list.length; x++) {
                             for(let y=x+1; y<list.length; y++) {
                                 if(this.sees(list[x], list[y])) return true;
                             }
                         }
                         return false;
                     };
                     
                     if (hasConflict(colorOneNodes)) removeColor1 = true;
                     if (hasConflict(colorTwoNodes)) removeColor2 = true;
                     
                     if (removeColor1) {
                         colorOneNodes.forEach(n => {
                             let idx = candidates[n.r][n.c].indexOf(num);
                             if(idx!==-1) candidates[n.r][n.c].splice(idx,1);
                         });
                         changed = true;
                     }
                     if (removeColor2) {
                         colorTwoNodes.forEach(n => {
                             let idx = candidates[n.r][n.c].indexOf(num);
                             if(idx!==-1) candidates[n.r][n.c].splice(idx,1);
                         });
                         changed = true;
                     }
                     
                     if (!removeColor1 && !removeColor2) {
                         // Rule 2
                         for (let n of nodes) {
                             if (colors[n.idx] !== 0) continue; // Already in component
                             // If this node sees a node of color 1 AND a node of color 2, eliminate num from it
                             let sees1 = colorOneNodes.some(c1 => this.sees(n, c1));
                             let sees2 = colorTwoNodes.some(c2 => this.sees(n, c2));
                             if (sees1 && sees2) {
                                  let idx = candidates[n.r][n.c].indexOf(num);
                                  if(idx!==-1) {
                                      candidates[n.r][n.c].splice(idx,1);
                                      changed = true;
                                  }
                             }
                         }
                     }
                 }
             }
        }
        
        if (changed) {
            for(let i=0;i<9;i++) for(let j=0;j<9;j++) if(grid[i][j]===0 && candidates[i][j].length===1) grid[i][j] = candidates[i][j][0];
        }
        return grid;
    }
    sees(c1, c2) {
        if (c1.r === c2.r) return true;
        if (c1.c === c2.c) return true;
        if (Math.floor(c1.r/3) === Math.floor(c2.r/3) && Math.floor(c1.c/3) === Math.floor(c2.c/3)) return true;
        return false;
    }
}

class XYZWingStrategy extends Strategy {
    solve(grid) {
        console.log('Executing XYZ-Wing');
        let changed = false;
        let candidates = this.findCandidates(grid);
        
        // Find Pivot: 3 candidates {X,Y,Z}
        const triCells = [];
        for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(candidates[r][c].length===3) triCells.push({r,c, val: candidates[r][c]});
        const biCells = [];
        for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(candidates[r][c].length===2) biCells.push({r,c, val: candidates[r][c]});
        
        for (let pivot of triCells) {
            // Pivot has [X, Y, Z]
            // Need Pincer 1 (size 2) seeing Pivot, sharing 2 existing values. e.g. [X, Y]
            // Need Pincer 2 (size 2) seeing Pivot, sharing [X, Z] or [Y, Z]
            // BUT actually XYZ Wing:
            // Pivot [X,Y,Z]. Pincer1 sees P, has [X,Z]. Pincer2 sees P, has [Y,Z].
            // Z is common to all three.
            // Elim Z from cells seeing ALL THREE (Pivot, P1, P2)
            
            for (let i = 0; i < biCells.length; i++) {
                const p1 = biCells[i];
                if (!this.sees(pivot, p1)) continue;
                
                for (let j = i+1; j < biCells.length; j++) {
                     const p2 = biCells[j];
                     if (!this.sees(pivot, p2)) continue;
                     
                     // Check candidates
                     // Must have common candidate Z in P, P1, P2
                     const common = pivot.val.filter(x => p1.val.includes(x) && p2.val.includes(x));
                     if (common.length !== 1) continue;
                     const Z = common[0];
                     
                     // P1 union P2 union Pivot must be exactly X, Y, Z
                     const union = new Set([...pivot.val, ...p1.val, ...p2.val]);
                     if (union.size !== 3) continue;
                     
                     // Found pattern. Eliminate Z from shared visibility
                     for(let r=0; r<9; r++) {
                         for(let c=0; c<9; c++) {
                             if (grid[r][c]===0 && candidates[r][c].includes(Z)) {
                                 if ((r===pivot.r && c===pivot.c) || (r===p1.r && c===p1.c) || (r===p2.r && c===p2.c)) continue;
                                 if (this.sees({r,c}, pivot) && this.sees({r,c}, p1) && this.sees({r,c}, p2)) {
                                     const idx = candidates[r][c].indexOf(Z);
                                     if (idx !== -1) {
                                         candidates[r][c].splice(idx, 1);
                                         changed = true;
                                     }
                                 }
                             }
                         }
                     }
                }
            }
        }
        
        if (changed) {
            for(let i=0;i<9;i++) for(let j=0;j<9;j++) if(grid[i][j]===0 && candidates[i][j].length===1) grid[i][j] = candidates[i][j][0];
        }
        return grid;
    }
    
    sees(c1, c2) {
        if (c1.r === c2.r) return true;
        if (c1.c === c2.c) return true;
        if (Math.floor(c1.r/3) === Math.floor(c2.r/3) && Math.floor(c1.c/3) === Math.floor(c2.c/3)) return true;
        return false;
    }
}

class StrategyFactory {
    createStrategy(strategyName) {
        switch (strategyName) {
            case 'xwing': // fixed key to match constants.js
            case 'x-wing':
                return new XWingStrategy();
            case 'rectangleelimination': // fixed key to match constants.js
            case 'rectangle-elimination':
                return new RectangleEliminationStrategy();
            case 'hiddensingles':
                return new HiddenSinglesStrategy();
            case 'nakedpairs':
                return new NakedPairsStrategy();
            case 'hiddenpairs':
                return new HiddenPairsStrategy();
            case 'pointingpairs':
                return new PointingPairsStrategy();
            case 'boxlinereduction':
                return new BoxLineReductionStrategy();
            case 'triples':
                return new TriplesStrategy();
            case 'bugplusone':
                return new BUGPlusOneStrategy();
            case 'uniquerectangles':
                return new UniqueRectanglesStrategy();
            case 'remotepairs':
                return new RemotePairsStrategy();
            case 'ywing':
                return new YWingStrategy();
            case 'simplecolouring':
                return new SimpleColouringStrategy();
            case 'quads':
                return new QuadsStrategy();
            case 'swordfish':
                return new SwordfishStrategy();
            case 'xyzwing':
                return new XYZWingStrategy();
            default:
                throw new Error(`Strategy ${strategyName} not found`);
        }
    }
}

module.exports = {
    StrategyFactory,
};







